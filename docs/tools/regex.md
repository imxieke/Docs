# Regex

### Rules
```shell
^abc 			Start
abc$ 			End
^abd$ 			abc start and end
```

指定预定义的字符集
字符	含义
\d	任意一个十进制数字[0-9]
\D	任意一个非十进制数字
\s	任意一个空白字符(空格、换行符、换页符、回车符、字表符)
\S	任意一个非空白字符
\w	任意一个单词字符
\W	任意个非单词字符

单词定界符
我们在查找的一个单词的时候，如an是否在一个字符串”gril and body”中存在，很明显如果匹配的话，an肯定是可以匹配字符串“gril and body”匹配到，怎样才能让其匹配单词，而不是单词的一部分呢？这时候，我们可以是哟个单词定界符\b。 
\ban\b 去匹配”gril and body”的话，就会提示匹配不到。 
当然还有一个大写的\B，它的意思，和\b正好相反，它匹配的字符串不能使一个完整的单词，而是其他单词或字符串中的一部分。如\Ban\B。

选择字符(|) ，表示或
选择字符表示或的意思。如Aa|aA，表示Aa或者是aA的意思。注意使用”[]”与”|”的区别，在于”[]”只能匹配单个字符，而”|”可以匹配任意长度的字符串。在使用”[]”的时候，往往配合连接字符”-“一起使用，如[a-d],代表a或b或c或d。

排除字符，排除操作
正则表达式提供了”^”来表示排除不符合的字符，^一般放在[]中。如[^1-5]，该字符不是1~5之间的数字。

限定符(？*+{n，m})
限定符主要是用来限定每个字符串出现的次数。

### 限定字符含义

```
？	零次或一次
*	零次或多次
+	一次或多次
{n}	n次
{n,}	至少n次
{n,m}	n到m次
\d	匹配一个数字字符。等价于 [0-9]
\D	匹配一个非数字字符。等价于 [^0-9]
\f	匹配一个换页符。等价于 \x0c 和 \cL
\n	匹配一个换行符。等价于 \x0a 和 \cJ
\r	匹配一个回车符。等价于 \x0d 和 \cM
\s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]
\S	匹配任何非空白字符。等价于 [^ \f\n\r\t\v]
\t	匹配一个制表符。等价于 \x09 和 \cI
\v	匹配一个垂直制表符。等价于 \x0b 和 \cK
\w	匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’
\W	匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’
\xn	匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ & “1”。正则表达式中可以使用 ASCII 编码。
\nm	标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 • \nm 将匹配八进制转义值 nm。	
\nml	如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
. 匹配除 “\n” 之外的任何单个字符
^ 匹配输入字符串的开始位置。在字符域[]中表示取反，如'[^\w]'等于'\w';而^\w表示以单词字符开头。
$ 匹配输入字符串的结束位置。例'\w$'表示以单词字符结尾
？ 匹配前面的子表达式零次或一次 等价于 {0,1}，例如，"do(es)?" 可以匹配 "do" 或 "does"。
* 匹配前面的子表达式零次或多次，等价于{0,}。例如，zo* 能匹配 "z" 、 "zo"、'zoo'
+ 匹配前面的子表达式一次或多次，等价于{1,}例如，'zo+' 能匹配 "zo" 以及 "zoo"
{n} n 为非负整数,匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 或‘Booob’，但是能匹配 "food" 中的两个 o。
{n,} n 为非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
{n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
[] 字符集合(字符域)。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
() 匹配 ()内的内容 并获取这一匹配。搭配\n(n为大于1的整数)，‘http://baidu.com’若表达式：‘（\w+） (:)\/\/.*\1’则匹配‘http://baidu.comhttp’,\1表示http。
(?:) 匹 配 但不获取匹配结果，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。上面表达式若改为'（?:\w+）(:)\/\/.*\1'，则\1表示为：
| x|y,匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
[-] 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
(?=pattern)	正 向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹 配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹 配的搜索，而不是从包含预查的字符之后开始。
(?!pattern)	负 向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不 需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜 索，而不是从包含预查的字符之后开始

有时候最后定界符会有一个字母，如‘/as.*/i’,那这个i又是什么呢，这就是模式修正符

i	表示在和模式进行匹配进不区分大小写
m	将模式视为多行，使用^和$表示任何一行都可以以正则表达式开始或结束
s	如果没有使用这个模式修正符号，元字符中的"."默认不能表示换行符号,将字符串视为单行
x	表示模式中的空白忽略不计
e	正则表达式必须使用在preg_replace替换字符串的函数中时才可以使用(讲这个函数时再说)
A	以模式字符串开头，相当于元字符^
Z	以模式字符串结尾，相当于元字符$

U	正则表达式的特点：就是比较“贪婪”，使用该模式修正符可以取消贪婪模式

```

```php
$str = 'asddadsdasd';
$pattern = '/a.*d/';
preg_match($pattern,$str,$match);
var_dump($match) ;//asddadsdasd;
$str = 'asddadsdasd';                                  
$pattern = '/a.*d/U';//$pattern = '/a.*?d/';
preg_match($pattern,$str,$match);
var_dump($match) ;//asd
```

### php常用正则函数:

#### 匹配：preg_match()与preg_match_all()

1 `preg_match($pattern,$subject,[array &$matches])`
2 `preg_match_all($pattern,$subject,array &$matches)`

> 1 只会匹配一次，
 2 会把所有符合的字符串都匹配出来，并且放置到matches数组中，而且这两个函数都有一个整形的返回 值。1是一维数组，2是二维数组

替换：`preg_replace()`

mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &$count ]] )
搜索subject中匹配pattern的部分， 以replacement进行替换。

## ip
`((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}`
`/^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/`
`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$`

## 判断是否为 IP
`^((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}$`


## CIDR
`^(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([1-9]|[1-2]\d|3[0-2])$`
`^((\d|[1-9]\d|1\d\d|2([0-4]\d|5[0-5]))\.){3}((\d|[1-9]\d|1\d\d|2([0-4]\d|5[0-5]))\/){1}(\d|[1-3]\d)$`

## 效果最好
`((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}\/(2[0-9]|[0-9])`